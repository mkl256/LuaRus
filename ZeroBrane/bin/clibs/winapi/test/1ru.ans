//## ru 	 1.c
#вставить "utf8.h"

#вставить <stdio.h>
#вставить <assert.h>

целое входит_в_класс(беззнак юникод_символ, беззнак * множество){
	пока(*множество){
		если( *множество<=юникод_символ && *(множество+1)>=юникод_символ ) возврат 1;
		множество += 2;
	}
	множество++;
	пока(*множество){
		если( *множество==юникод_символ ) возврат 1;
		множество++;
	}	
	возврат 0;
}

беззнак * нов_симв_класс(пост симв * с0, пост симв * скн){
	пост симв* с = с0;
	беззнак буффер[200], юникод_символ;
	size_t sh, sh1;
	sh = юник8_декоде(с, скн, &юникод_символ);
	
	возврат 0;
}

беззнак перв_ид[] = {1040,1103,'A','z', 0,95, 0};
беззнак след_ид[] = {1040,1103,'A','z',48,57, 0,95, 0};
беззнак цифра[] = {48,57, 0, 0};
беззнак пробелы[] = {0,10,13,9, 32, 0};
беззнак плюс_и_минус[] = {0,'+','-', 0};

структура правило;
опредтип структура регвыраж{
	объединение {
		беззнак * множество;
		беззнак юникод_символ;
		структура регвыраж * ре;
		структура регвыраж ** результат;
	};
	симв тип:4;
	симв соотв_повтор:3;
} регвыраж;


пост симв* соотв_регвыраж(пост симв* с0, пост симв* скн, регвыраж* ре);
пост симв* соотв_алтерн(пост симв* с, пост симв* скн, структура регвыраж** правила);
пост симв* соотв_сбаланс(пост симв* с, пост симв* скн, регвыраж** правила);


пост симв* соотв_регвыраж(пост симв* с0, пост симв* скн, регвыраж* ре){
	#	опред след_елем_регвыраж { ре++; ре_индекс++; }
	если(!ре) возврат NULL; утверждение(ре);
	пост симв* с = с0;
	пост симв* с1;
	пост симв* с2;
	беззнак юникод_символ;
	целое ре_индекс = 0;
	целое есть_совпадение = 0;
	целое счетчик_повторений = 0;
	size_t sh, sh1;
	sh = юник8_декоде(с, скн, &юникод_символ);
	пока((ре)->тип){
		если(!юникод_символ || !sh) {
			есть_совпадение = 0;
		}иначе{
			выбор (ре->тип) {
			  при 1: есть_совпадение = ре->юникод_символ==юникод_символ; стоп;
			  при 2: есть_совпадение = входит_в_класс(юникод_символ, ре->множество); стоп;
			  при 3: с2 = соотв_алтерн(с, скн, ре->результат);
			  	есть_совпадение = с2>с; 
			  	если( есть_совпадение ) sh = с2-с; 
					стоп;
			  при 4: с2 = соотв_регвыраж(с, скн, ре->ре);
			  	есть_совпадение = с2>с; 
			  	если( есть_совпадение ) sh = с2-с; 
			  	стоп;
			  поумолчанию : печатьф("unknown expr type %3d in re %p:%3d\n", ре->тип, ре, ре_индекс); exit(5); стоп;
			}
		}
		если(ре->соотв_повтор&0x4) есть_совпадение = !есть_совпадение;
		если( есть_совпадение ){
			с += sh;
			sh = юник8_декоде(с, скн, &юникод_символ);
			если(!(ре->соотв_повтор&0x1)) след_елем_регвыраж иначе{ счетчик_повторений++; }
		}иначе{
			если(((ре->соотв_повтор&0x1) && счетчик_повторений) || 
				(ре->соотв_повтор&0x2)){
				счетчик_повторений = 0;
				след_елем_регвыраж; //s += sh;
				если(!юникод_символ || !sh){ стоп; }иначе{ продолжить;}
			}
			возврат NULL;
		}
	}
	возврат с;
	#разопред след_елем_регвыраж 
}

опредтип структура правило{
	пост симв имя[20];
  регвыраж *ре;
} правило;

пост симв* соотв_алтерн(пост симв* с, пост симв* скн, регвыраж** правила){
	пост симв* с1 = NULL;
	целое ри;
	для(; правила; правила++){
		с1 = соотв_регвыраж(с, скн, *правила);
		// printf("\ttoken %s\t%d\n", rules[ri].name, s1);		
		если(с1) возврат с1;
	}
	возврат NULL;
}

пост симв* соотв_сбаланс(пост симв* с0, пост симв* скн, регвыраж** правила){
	беззнак юникод_символ;
	регвыраж* open = *правила; //rules++;
	регвыраж* close = 0;//*rules ? *(rules) : open;
	регвыраж* esc = 0;//*rules ? *rules : NULL;
	печатьф("%p\t%p\t%p\n", open, close, esc);
	пост симв* с = с0;
	пост симв* с1 = соотв_регвыраж(с, скн, open);
	печатьф("\t%p\t%p\t%p\n", с, с1, с0);
	целое b = 1;
	пока (с1 && с1<=скн && с1>с){
		печатьф("\t\t%p\t%p\t%p\n", с, с1, с0);
		с = с1;
		если(!с) стоп;
		с1 = соотв_регвыраж(с, скн, open);
	  если(с1>с){
	  	b--; если(b==0) возврат с1; 
	  }иначе{ 
	  	с1+=юник8_декоде(с, скн, &юникод_символ);
	  	// s1 = is_re(s, se, open);
	  	// if(s1) b++; else s1+=utf8_decode(s, se, &ch);
	  }
	}
	// for(; rules; rules++){
	// 	s1 = ;
	// 	// printf("\ttoken %s\t%d\n", rules[ri].name, s1);		
	// 	if(s1) return s1;
	// }
	возврат NULL;
}
#ошибка g 
#опред РЕ(...) { __VA_ARGS__, {0,0,0} }
регвыраж ре1[] = РЕ( {9,1,1},{32,1,3}, {10,1,0} );
регвыраж ре2[] = { {9,1,1}, {10,1,0},{9,1,1},{перв_ид,2,1},{0,0,0} };

регвыраж число_целое[] = { {цифра,2,1}, {0,0,0} };
регвыраж число_с_множ[] = { {цифра,2,1}, {'e',1,0}, {плюс_и_минус,2,2},{цифра,2,1}, {0,0,0} };

регвыраж* правила_веществ_чисел[] = {
	число_с_множ, число_целое, NULL
};

регвыраж ид[] = { {перв_ид,2,0}, {след_ид,2,3}, {0,0,0} };
регвыраж представление[] = { {'#',1,0}, {'#',1,0}, {пробелы,2,7}, {';',1,0}, {0,0,0} };
// regexp num_int[] = { {digit,2,1}, {0,0,0} };
регвыраж ws_re[] = { {пробелы,2,1}, {0,0,0} };
регвыраж число_веществ[] = { {цифра,2,3}, {'.',1,0}, 
	{правила_веществ_чисел,3,0}, 
	{0,0,0} };
регвыраж open_str[] = {  {(беззнак)'"',1,7}, {0,0,0} };
// regexp open_str[] = { {'"',1,0}, {0,0,0} };
регвыраж стр[] = { 
{'"',1,0},  
{open_str,4,3}, 
{'"',1,0}, {0,0,0} };

правило правила[] = {
	{ "ppp", представление },
	{ "id", ид },
	{ "num_float", число_веществ  },	
	{ "num_int", число_целое  },
	{ "ws", ws_re  },		
	{ "str", стр  },			
	{"", NULL}
};
	пост симв * Match(пост симв *с, пост симв *es, пост симв *p, пост симв *ep);

целое main(){

	симв data[2048];
	симв *с0="	\t\t  \10 123456$";
	пост симв *скн=data+размерность(data);
	пост симв* с=data;
	ФАЙЛ* f = фоткрыть("src.txt", "r");
	печатьф("num_exp %p\n", 
);
	size_t l = фчтение(data, 1, размерность(data)-1, f);
	data[l] = '\0';
	скн=data+l;
	печатьф("%ld\t%ld\n", l, l++);
	беззнак юникод_символ;
	size_t sh;
	пост симв* rr = соотв_регвыраж(с, скн, ре1);
	печатьф("rr1==%d\n", rr-с);
	печатьф("rr2==%d\n", соотв_регвыраж(с, скн, ре2)-с);
	печатьф("id==%d\n", соотв_регвыраж(с, скн, ид)-с);
	печатьф("num_float==%d\n", соотв_регвыраж(с, скн, число_веществ)-с);
	печатьф("rr11==%d\n", соотв_регвыраж(с0, с0+размерность(с0), ре1)-с0);
	
	пост симв* с1;
	целое ри;
	пока (с<скн){
		с1 = NULL;
		для(ри=0; правила[ри].ре; ри++){
			печатьф("\ttoken %p:%s\n", правила[ри].ре, правила[ри].имя);		
			с1 = соотв_регвыраж(с, скн, правила[ри].ре);
			если(с1) стоп;
		}
		// printf("%p\t", s1);
		если(!с1){
			печатьф("unknown token \"%s\"\n", с );
			возврат 0;
		}иначе{
			печатьф("token %s\t%d\t", правила[ри].имя, с1-с);
			putchar('\"');
			пост симв* с2;
			для(с2=с; с2<с1; с2++){
				выбор (*с2){
				  при 9: печатьф("\\t"); стоп;
				  при 13: печатьф("\\n"); стоп;
				  при 10: печатьф("\\l"); стоп;
				  поумолчанию: putchar(*с2); стоп;
				}
			} 
			печатьф("\"\n");		
		}
	  с = с1;
	}
	
	с=data;
	// for(sh=utf8_decode(s, se, &ch); ch;sh=utf8_decode(s, se, &ch)){
	// 	// printf("\"");
	// 	// int i;
	// 	// for(i=0; i<sh; i++) printf("%c", *(s+i));
	// 	// printf("\"\t");
	// 	printf("%8ld\t%8ld", ch, sh);	
	// 	printf("\t%5d", is_class(ch, first_id));
	// 	printf("\t%5d", is_class(ch, next_id));
	// 	printf("\t%5d", is_class(ch, digit));
	// 	printf("\t%5d", is_class(ch, ws));
	// 	printf("\n");	
	// 	s += sh;
	// }
	// printf("\n%s", data);
	// printf("\n------------------\n");
	// const char p[] = "(.+)";
	// const char * s4 = Match(s, se, p, p+sizeof(p)+1);

	возврат 0;
}
