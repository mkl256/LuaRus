//## en          1.c
#include "utf8.h"

#include <stdio.h>
#include <assert.h>

/*
 * unidata.h - generated by parseucd.lua
 */
#ifndef unidata_h
#define unidata_h

typedef struct range_table {
    unsigned int first;
    unsigned int last;
    int step;
} range_table;

typedef struct conv_table {
    unsigned int first;
    unsigned int last;
    int step;
    int offset;
} conv_table;



static int find_in_range(range_table *t, size_t size, unsigned ch) {
  size_t begin, end;

  begin = 0;
  end = size;

  while (begin < end) {
    int mid = (begin + end) / 2;
    if (t[mid].last < ch)
      begin = mid + 1;
    else if (t[mid].first > ch)
      end = mid;
    else
      return (ch - t[mid].first) % t[mid].step == 0;
  }

  return 0;
}


static struct range_table t1_charset[] = {
	{ 32, 48, 16 },
	{ 49, 57, 1 },
	{ 95, 95, 1 },
};

static struct range_table l2_charset[] = {
	{ 1, 2, 1 },
	{ 2, 3, 1 },
	{ 3, 7, 4 },
	{ 55, 55, 1 },
};

#endif /* unidata_h */


int is_class(unsigned ch, unsigned * set){
	while(*set){
		if( *set<=ch && *(set+1)>=ch ) return 1;
		set += 2;
	}
	set++;
	while(*set){
		if( *set==ch ) return 1;
		set++;
	}
	return 0;
}

unsigned * new_charset(const char * s0, const char * se){
	const char* s = s0;
	unsigned buff[200], ch;
	size_t sh, sh1;
	sh = utf8_decode(s, se, &ch);

	return 0;
}

unsigned first_id[] = {1040,1103,'A','z', 0,95, 0};
unsigned next_id[] = {1040,1103,'A','z',48,57, 0,95, 0};
unsigned digit[] = {48,57, 0, 0};
unsigned ws[] = {0,10,13,9, 32, 0};
unsigned add_sub[] = {0,'+','-', 0};

struct rule;
typedef struct regexp{
	union {
		unsigned * set;
		unsigned ch;
		struct regexp * re;
		struct regexp ** res;
	};
	char type:4;
	char is_rep:3;
} regexp;


const char* is_re(const char* s0, const char* se, regexp* re);
const char* is_alt(const char* s, const char* se, struct regexp** rules);
const char* is_balanced(const char* s, const char* se, regexp** rules);


const char* is_re(const char* s0, const char* se, regexp* re){
	#	define next_re_expr { re++; re_idx++; }
	if(!re) return NULL; assert(re);
	const char* s = s0;
	const char* s1;
	const char* s2;
	unsigned ch;
	int re_idx = 0;
	int is_match = 0;
	int rep_count = 0;
	size_t sh, sh1;
	sh = utf8_decode(s, se, &ch);
	while((re)->type){
		if(!ch || !sh) {
			is_match = 0;
		}else{
			switch (re->type) {
			  case 1: is_match = re->ch==ch; break;
			  case 2: is_match = is_class(ch, re->set); break;
			  case 3: s2 = is_alt(s, se, re->res);
			  	is_match = s2>s;
			  	if( is_match ) sh = s2-s;
					break;
			  case 4: s2 = is_re(s, se, re->re);
			  	is_match = s2>s;
			  	if( is_match ) sh = s2-s;
			  	break;
			  default : printf("unknown expr type %3d in re %p:%3d\n", re->type, re, re_idx); exit(5); break;
			}
		}
		if(re->is_rep&0x4) is_match = !is_match;
		if( is_match ){
			s += sh;
			sh = utf8_decode(s, se, &ch);
			if(!(re->is_rep&0x1)) next_re_expr else{ rep_count++; }
		}else{
			if(((re->is_rep&0x1) && rep_count) ||
				(re->is_rep&0x2)){
				rep_count = 0;
				next_re_expr; //s += sh;
				if(!ch || !sh){ break; }else{ continue;}
			}
			return NULL;
		}
	}
	return s;
	#undef next_re_expr
}

typedef struct rule{
	const char name[20];
  regexp *re;
} rule;

const char* is_alt(const char* s, const char* se, regexp** rules){
	const char* s1 = NULL;
	int ri;
	for(; rules; rules++){
		s1 = is_re(s, se, *rules);
		// printf("\ttoken %s\t%d\n", rules[ri].name, s1);
		if(s1) return s1;
	}
	return NULL;
}

const char* is_balanced(const char* s0, const char* se, regexp** rules){
	unsigned ch;
	regexp* open = *rules; //rules++;
	regexp* close = 0;//*rules ? *(rules) : open;
	regexp* esc = 0;//*rules ? *rules : NULL;
	printf("%p\t%p\t%p\n", open, close, esc);
	const char* s = s0;
	const char* s1 = is_re(s, se, open);
	printf("\t%p\t%p\t%p\n", s, s1, s0);
	int b = 1;
	while (s1 && s1<=se && s1>s){
		printf("\t\t%p\t%p\t%p\n", s, s1, s0);
		s = s1;
		if(!s) break;
		s1 = is_re(s, se, open);
	  if(s1>s){
	  	b--; if(b==0) return s1;
	  }else{
	  	s1+=utf8_decode(s, se, &ch);
	  	// s1 = is_re(s, se, open);
	  	// if(s1) b++; else s1+=utf8_decode(s, se, &ch);
	  }
	}
	// for(; rules; rules++){
	// 	s1 = ;
	// 	// printf("\ttoken %s\t%d\n", rules[ri].name, s1);
	// 	if(s1) return s1;
	// }
	return NULL;
}

#define RE(...) { __VA_ARGS__, {0,0,0} }
regexp re1[] = RE( {9,1,1},{32,1,3}, {10,1,0} );
regexp re2[] = { {9,1,1}, {10,1,0},{9,1,1},{first_id,2,1},{0,0,0} };

regexp num_int[] = { {digit,2,1}, {0,0,0} };
regexp num_exp[] = { {digit,2,1}, {'e',1,0}, {add_sub,2,2},{digit,2,1}, {0,0,0} };

regexp* num_float_rules[] = {
	num_exp, num_int, NULL
};

regexp id[] = { {first_id,2,0}, {next_id,2,3}, {0,0,0} };
regexp skin[] = { {'#',1,0}, {'#',1,0}, {ws,2,7}, {';',1,0}, {0,0,0} };
// regexp num_int[] = { {digit,2,1}, {0,0,0} };
regexp ws_re[] = { {ws,2,1}, {0,0,0} };
regexp num_float[] = { {digit,2,3}, {'.',1,0},
	{num_float_rules,3,0},
	{0,0,0} };
regexp open_str[] = {  {(unsigned)'"',1,7}, {0,0,0} };
// regexp open_str[] = { {'"',1,0}, {0,0,0} };
regexp str[] = {
{'"',1,0}const char* rr = is_re(s, se, re1);
	printf("rr1==%d\n", rr-s);
	printf("rr2==%d\n", is_re(s, se, re2)-s);
	printf("id==%d\n", is_re(s, se, id)-s);
	printf("num_float==%d\n", is_re(s, se, num_float)-s);
	printf("rr11==%d\n", is_re(s0, s0+sizeof(s0), re1)-s0);

	const char* s1;
	int ri;
	while (s<se){
		s1 = NULL;
		for(ri=0; rules[ri].re; ri++){
			printf("\ttoken %p:%s\n", rules[ri].re, rules[ri].name);
			s1 = is_re(s, se, rules[ri].re);
			if(s1) break;
		}
		// printf("%p\t", s1);
		if(!s1){
			printf("unknown token \"%s\"\n", s );
			return 0;
		}else{
			printf("token %s\t%d\t", rules[ri].name, s1-s);
			putchar('\"');
			const char* s2;
			for(s2=s; s2<s1; s2++){
				switch (*s2){
				  case 9: printf("\\t"); break;
				  case 13: printf("\\n"); break;
				  case 10: printf("\\l"); break;
				  default: putchar(*s2); break;
				}
			}
			printf("\"\n");
		}
	  s = s1;
	}

	s=data;
	// for(sh=utf8_decode(s, se, &ch); ch;sh=utf8_decode(s, se, &ch)){
	// 	// printf("\"");
	// 	// int i;
	// 	// for(i=0; i<sh; i++) printf("%c", *(s+i));
	// 	// printf("\"\t");
	// 	printf("%8ld\t%8ld", ch, sh);
	// 	printf("\t%5d", is_class(ch, first_id));
	// 	printf("\t%5d", is_class(ch, next_id));
	// 	printf("\t%5d", is_class(ch, digit));
	// 	printf("\t%5d", is_class(ch, ws));
	// 	printf("\n");
	// 	s += sh;
	// }
	// printf("\n%s", data);
	// printf("\n------------------\n");
	// const char p[] = "(.+)";
	// const char * s4 = Match(s, se, p, p+sizeof(p)+1);
	for(ch=0; ch<=60; ch++) printf("%2d: %s\n",
		find_in_range(l2_charset, sizeof(l2_charset)/sizeof(l2_charset[0]), ch) ? "found" : ""
	);

	return 0;
}
