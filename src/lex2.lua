функция аст(имя, аргументы, стршаблон)
	локал мт = {
		__concat = функция(а, б)
			возврат tostring(а)..tostring(б)
		конец,
		__tostring = функция(я)
			локал с = ""
			
			возврат стршаблон:gsub("%%%(", "\1")
				:gsub("%)%%", "\2")
				:gsub("(%b\1\2)", функция(секция)
					локал к = 0
					локал с = секция:sub(2, -2):gsub("%%([%w%r_]+)", функция(назв)
						если не я[назв] возврат конец
						к = к + 1
						возврат tostring(я[назв])
					конец)
					возврат к==0 и "" или с
				конец)
				:gsub("%%([%w%r_]+)", функция(назв)
					возврат tostring(я[назв] или "")
				конец)
		конец,
		__индекс = { имя=имя }
	}

	возврат функция(...)
		локал новый, к = {}, 1
		для арг из аргументы:gmatch"([%w%r_]+)"
			новый[арг] = выбор(к, ...)
			к = к + 1
		конец
		возврат устметатаб(новый, мт)
	конец

конец

вызов_функции = аст("вызов", "имя, аргументы", "%имя%((%аргументы))%")
ветвление = аст("ветвление", "условие, тогда, иначе", "если %условие тогда %тогда%( иначе %иначе)% конец")
новВырТип = аст("выртипа", "пост, имятипа, указатель", "%(%пост )%%имятипа%указатель")
новТипАрг = аст("типарг", "пост, имятипа, указатель, имя", "%(%пост )%%имятипа%указатель %имя")



функция требстр(итер, ток)
	локал итер_поз, л, с = начать_разбор(итер)
	если с~=ток
		строка.токитер_вернуть(итер, итер_поз)
		лексошибка(итер, "синт. ошибка: ожидается `"..ток.."` получен `"..с.."`", 3)
	конец
конец

функция тестстр(итер, ток)
	локал итер_поз, л, с = начать_разбор(итер)
	если с~=ток тогда
		строка.токитер_вернуть(итер, итер_поз)
		возврат ложь
	конец
	возврат истина
конец

функция тестспис(итер, ток)
	локал итер_поз = строка.токитер_запомнить(итер)
	локал л,с = итер()
	если л=="ws"  л,с = итер() конец
	если ток:найти(с)
		возврат с
	конец
	строка.токитер_вернуть(итер, итер_поз)
	возврат ложь
конец

функция тестток(итер, ток)
	локал итер_поз = строка.токитер_запомнить(итер)
	локал л, с = итер()
	если л=="ws" тогда л, с = итер() конец
	если л~=ток
		строка.токитер_вернуть(итер, итер_поз)
		возврат ложь
	конец
	возврат с
конец

функция стрток(итер)
	локал л, с = итер()
	если л=="ws"  л, с = итер() конец
	возврат с
конец




функция Л(лекс)
	возврат функция(итер)
		локал итер_поз, л, с = начать_разбор(итер)
		если л==лекс тогда возврат с конец
		строка.токитер_вернуть(итер, итер_поз)
		возврат ложь
	конец
конец

функция Лтреб(лекс)
	возврат функция(итер)
		локал л, с = итер()
		если л=="ws" тогда л, с = итер() конец
		если л==лекс тогда возврат с конец
		лексошибка(итер, "ожидается "..лекс..", получен `"..с.."`", 3)
	конец
конец





локал ключевые_слова = {
	["и"]=истина, ["стоп"]=истина, ["начало"]=истина, ["иначе"]=истина, ["иесли"]=истина,
	["конец"]=истина, ["ложь"]=истина, ["для"]=истина, ["функция"]=истина, ["идина"]=истина, ["если"]=истина,
	["из"]=истина, ["локал"]=истина, ["нуль"]=истина, ["не"]=истина, ["или"]=истина, ["повторять"]=истина,
	["возврат"]=истина, ["тогда"]=истина, ["истина"]=истина, ["покуда"]=истина, ["пока"]=истина
}

функция ИДтреб(итер)
	локал л, с = итер()
	если л=="ws" тогда л, с = итер() конец
	если л=="id" и не ключевые_слова[с] тогда возврат с конец
	лексошибка(итер, "ожидается имя, получен `"..с.."`", 3)
конец

ид = Л"id"

функция начать_разбор(итер)
	локал итер_поз = строка.токитер_запомнить(итер)
	локал л, с, н, к = итер()
	если л=="ws"  л, с, н, к = итер() конец
	возврат итер_поз, л, с, н, к
конец

функция лексошибка(итер, сообщение, индекс)
	локал лин, кол = строка.токитер_позиция(итер)
	печать([[C:\dev\luaRu5.3.4\lua-5.3.4\src\lextest.lua:]]..(лин)..":"..кол..": "..сообщение)
	печать([[	C:\dev\luaRu5.3.4\lua-5.3.4\src\lex.lua:]]..debug.getinfo(индекс или 2,"l").currentline..":")
	error""
	ос.выход()
конец

функция лекслог(итер, сообщение)
	локал лин, кол = строка.токитер_позиция(итер)
	возврат [[C:\dev\luaRu5.3.4\lua-5.3.4\src\lextest.lua:]]..(лин)..":"..кол..": "..сообщение
конец

функция СписокСРазделителями(элем, разд, непустой, название)
	возврат функция(итер)
		локал список = {}
		локал арг = элем(итер)
		если арг
			table.insert(список, арг)
			пока тестстр(итер, разд)
				локал арг = элем(итер)
				если не арг  лексошибка(итер, "отсутствует аргумент") конец
				table.insert(список, арг)
			конец
		иесли непустой
			лексошибка(итер, "отсутствуют аргументы")
		конец
		возврат устметатаб(список, {
			__concat = функция(а, б)
				возврат tostring(а)..tostring(б)
			конец,
			__tostring = функция(я)
				локал с = ""
				для к, эл из перечисли(я)
					с = с..tostring(эл)..(к==№я и "" или разд)
				конец
				возврат с
			конец,
			__metatable = название
		})
	конец
конец

функция СписокСОкончанием(элем, оконч, непустой, разд)
	локал разд = разд или ""
	возврат функция(итер)
		локал список = {}
		пока не тестстр(итер, оконч)
			локал арг, сообщ = элем(итер)
			если не арг тогда лексошибка(итер, "отсутствует аргумент "..(сообщ или "")) конец
			table.insert(список, арг)
		конец
		если непустой и №список==0
			лексошибка(итер, "отсутствуют аргументы")
		конец
		возврат устметатаб(список, {
			__tostring = функция(я)
				локал с = ""
				для к, эл из перечисли(я)
					с = с..tostring(эл)..(к==№я и "" или разд)
				конец
				возврат с
			конец,
		})
	конец
конец

функция Список(элем, непустой, разд)
	локал разд = разд или ""
	возврат функция(итер)
		локал список = {}
		локал арг, сообщ = элем(итер)
		пока арг
			table.insert(список, арг)
			арг, сообщ = элем(итер)
		конец
		если непустой и №список==0
			лексошибка(итер, "отсутствуют '"..debug.getinfo(1, "n").name.."' \n"..(сообщ или ""))
		конец
		возврат устметатаб(список, {
			__tostring = функция(я)
				локал с = ""
				для к, эл из перечисли(я)
					с = с..tostring(эл)..(к==№я и "" или разд)
				конец
				возврат с
			конец,
		})
	конец
конец

функция Значение1(итер)
	локал итер_поз, л, с = начать_разбор(итер)


	если л=="id" и не ключевые_слова[с]
		если тестстр(итер, "(")
			локал аргументы = СписокЗначений(итер)
			требстр(итер, ")")
			возврат ""..с.."("..table.concat(аргументы, ', ')..")"
		-- иесли тестстр(итер, "[")

		иначе
			возврат ""..с
		конец
	иесли л=="num"
		возврат ""..с
	иесли л=="str"
		возврат ""..с
	конец

	строка.токитер_вернуть(итер, итер_поз)
	возврат ложь
конец

функция Значение2(итер)
	локал итер_поз = строка.токитер_запомнить(итер)


	если тестстр(итер, "(")
		локал а = Значение(итер)
		требстр(итер, ")")
		возврат "("..а..")"
	конец

	локал опер = тестспис(итер, "не   #     -     ~")
	если опер
		локал а = ПриоритетОпераций(Значение2, "^")(итер)
		если не а  лексошибка(итер, "отсутствует операнд") конец
		возврат "("..опер.." "..а..")"
	-- иесли тестстр(итер, "[")
	иначе
		локал а = Значение1(итер)
		возврат а
	конец

	строка.токитер_вернуть(итер, итер_поз)
	возврат ложь
конец



функция ПриоритетОпераций(значение, операции, ...)
	если не операции  возврат значение конец
	локал функция опер_фн(итер)
		локал итер_поз = строка.токитер_запомнить(итер)
		локал а = значение(итер)
		если а
			локал опер = тестспис(итер, операции)
			если опер
				локал б = опер_фн(итер)
				если не б  лексошибка(итер, "отсутствует второй операнд") конец
				возврат "("..а.." "..опер.." "..б..")"
			-- иесли тестстр(итер, "[")
			иначе
				возврат а
			конец
		конец

		строка.токитер_вернуть(итер, итер_поз)
		возврат ложь
	конец
	возврат ПриоритетОпераций(опер_фн, ...)
конец

Значение = ПриоритетОпераций(Значение2, "* / // %", "+ -", "..", "<< >>", "&", "~", "|", "< > <= <= == ~=", "и", "или")
СписокЗначений = СписокСРазделителями(Значение, ",")

функция отступы(список)
	локал с = ""
	для инд, элем из перечисли(список)
		с = "\t"..элем.."\n"
	конец
	возврат с
конец

функция отступ(стр)
	-- локал с = ""
	-- для инд, элем из перечисли(список)
	-- 	с = "\t"..элем.."\n"
	-- конец
	возврат (tostring(стр):gsub("([^\n]*)", "  %1"))
конец

функция ТипВыр(итер)
	локал итер_поз, л, с = начать_разбор(итер)
	локал аттр_пост = ложь
	локал имятипа
	если с=="пост" тогда 
		аттр_пост = истина
		имятипа = ид(итер)
	иначе
		если л=="id" тогда 
			имятипа = с 
		иначе
			строка.токитер_вернуть(итер, итер_поз)
			возврат ложь
		конец
	конец
 
	если не имятипа тогда лексошибка(итер, "отсутствует имя типа") конец

	локал указатель = 0
	пока тестстр(итер, "*") начало
		указатель = указатель + 1
	конец

	возврат новВырТип(аттр_пост и "пост" или ложь, имятипа, строка.повторить("*", указатель))
конец

функция ТипАрг(итер)
	локал итер_поз, л, с = начать_разбор(итер)
	локал аттр_пост = ложь
	локал имятипа
	если с=="пост" тогда 
		аттр_пост = истина
		имятипа = ид(итер)
	иначе
		если л=="id" тогда 
			имятипа = с 
		иначе
			строка.токитер_вернуть(итер, итер_поз)
			возврат ложь
		конец
	конец
 
	если не имятипа тогда лексошибка(итер, "отсутствует имя типа") конец

	локал указатель = 0
	пока тестстр(итер, "*") начало
		указатель = указатель + 1
	конец

	локал имяарг = ид(итер)
	если не имяарг тогда 
		если аттр_пост или указатель>0 тогда
			лексошибка(итер, "отсутствует имя аргумента") 
		иначе
			возврат имятипа
		конец
	конец

	возврат новТипАрг(аттр_пост и "пост" или ложь, имятипа, строка.повторить("*", указатель), имяарг)
-- (аттр_пост и "const " или "")..имятипа..(строка.повторить("*", указатель)).." "..имяарг
конец

СписокАргументов = СписокСРазделителями(ТипАрг, ",", ложь, "СписокАргументов")

функция Предложение(итер)
	локал итер_поз, л, с = начать_разбор(итер)
	если л=="id"
		если с=="если"
			локал усл = Значение(итер)
			тестстр(итер, "тогда")
			локал блок_тогда, блоки_иесли, блок_иначе = код(итер), {}
			пока тестстр(итер, "иесли")
				локал бие = { условие = Значение(итер) }
				тестстр(итер, "тогда")
				бие.тело = код(итер)
				table.insert(блоки_иесли, бие)
			конец
			если тестстр(итер, "иначе")
				блок_иначе = код(итер)
			конец
			требстр(итер, "конец")
			локал сбие = ""
			для _, бие из перечисли(блоки_иесли)
				сбие = сбие .. "\nelseif "..бие.условие.." then \n"..отступ(table.concat(бие.тело, "\n"))
			конец

			возврат "if "..усл.." then \n"..отступ(блок_тогда)..сбие..
				(блок_иначе и ("\nelse \n"..отступ(table.concat(блок_иначе, "\n"))) или "").."\nend "
		иесли с=="пока"
			локал усл = Значение(итер)
			тестстр(итер, "начало")
			локал тело_цикла = блок(итер)
			возврат "while "..усл.." do \n"..отступ(table.concat(тело_цикла, "\n")).."\nend "
		иесли с=="функция"
			локал имя = ид(итер)
			требстр(итер, "(")
			локал аргументы = СписокАргументов(итер)
			требстр(итер, ")")
			локал тело_фн = блок(итер)
			возврат "function "..имя.."("..(аргументы)..")\n"..отступ(table.concat(тело_фн, "\n")).."\nend "
		иесли с=="возврат"
			локал аргументы = СписокЗначений(итер)
			возврат "return "..table.concat(аргументы, ', ')
		иесли с=="локал"
			локал имя = ИДтреб(итер)
			если тестстр(итер, "=")
				локал знач = Значение(итер)
				если не знач  лексошибка(итер, "отсутствует присваиваемое значение") конец
				возврат "локал "..имя.." = "..знач
			иначе
				возврат "локал "..имя
			конец
		иесли не ключевые_слова[с]
			локал с = левзнач(итер, с)
			если тестстр(итер, "(")
				локал аргументы = СписокЗначений(итер)
				требстр(итер, ")")
				возврат ""..с.."("..table.concat(аргументы, ', ')..")"
			иесли тестстр(итер, "=")
				локал знач = Значение(итер)
				если не знач  лексошибка(итер, "отсутствует присваиваемое значение") конец
				возврат ""..с.." = "..знач
			иначе
				строка.токитер_вернуть(итер, итер_поз)
				локал тарг = ТипАрг(итер)
				если тарг тогда
					если тестстр(итер, "=")
						локал знач = Значение(итер)
						если не знач  лексошибка(итер, "отсутствует присваиваемое значение") конец
печать(тарг, дайметатаб(тарг))
						возврат тарг.." = "..знач
					иначе
						возврат тарг
					конец
				конец

				локал сообщение = лекслог(итер, "ожидается `=` или `(` после `"..с.."`, получено `"..стрток(итер).."`")
				строка.токитер_вернуть(итер, итер_поз)
				возврат ложь, сообщение
			конец
		конец
	иесли л=="label"
		локал имя = ид(итер)
		требстр(итер, "::")
		возврат "::"..имя.."::"
	конец

	строка.токитер_вернуть(итер, итер_поз)
	возврат ложь
конец

функция левзнач(итер, знач0)
	если тестстр(итер, ".")
		локал поле = ид(итер)
		если не поле лексошибка(итер, "отсутствует имя поля") конец
		возврат левзнач(итер, ""..знач0.."."..поле)
	иесли тестстр(итер, "[")
		локал поле = Значение(итер)
		если не поле лексошибка(итер, "отсутствует имя поля") конец
		требстр(итер, "]")
		возврат левзнач(итер, ""..знач0.."["..поле.."]")
	иначе
		возврат знач0
	конец
конец


блок=СписокСОкончанием(Предложение, "конец", ложь, "\n")
код=Список(Предложение, истина, "\n")


исхкод = вв.открой("lextest.lua"):читай"*a"
итер_ток = исхкод:токениз("")
print(код(итер_ток), "\n------------\n", итер_ток())
ос.выход()

печать(вызов_функции("ф1", устметатаб({"666", 22}, {
		__tostring = функция(я)
			локал с = ""
			
			возврат table.concat(я, ', ')
		конец,
	})))
печать(вызов_функции("ф1"))
печать(ветвление("х==0", "х=1"))
печать(ветвление("х==0", "х=1", "х=0"))

локал граф = {
	["если"] = {},
	["пока"] = {},
	["функция"] = {},
	["возврат"] = {},
	["ид"] = {
		["="] = { 
			["Знач"] = {},
			[ложь] = tostring "отсутствует присваиваемое значение",	
		},
		["("] = {
			["Аргументы"] = {
				[")"] = {},
			},
			[")"] = {},
		},
	},
}
локал Знач = {
	["строка"] = {},
	["число"] = {},
	["ид"] = {
		["("] = {
			["Аргументы"] = {
				[")"] = {},
			},
			[")"] = {},
		},
	},

}
функция Д(п)
локал функция д2с(дрв, ур, списокобр)
	локал ур = ур или 0
	локал списокобр = списокобр или { [0] = 0}
	локал с = ""
	если списокобр[дрв] возврат " <"..списокобр[дрв]..">" конец
	списокобр[0] = списокобр[0] + 1
	списокобр[дрв] = списокобр[0]
	для кл, уз из пар(дрв)
		локал с1 = д2с(уз, ур+1, списокобр)
		с = с.."\n"..string.rep("\t", ур)..списокобр[уз]..":"..кл..с1
	конец

	возврат с
конец

	локал мт = {
		__tostring = д2с,
		__add = функция(а, б)
			возврат устметатаб({а, б}, мт)
		конец,
		__индекс = { имя=имя,
			добпер = функция(я, пер)
				локал узел = я
				для инд, элем из перечисли(пер)
					локал у = узел[элем] 
					если не у 
						у = {}
						узел[элем] = у
					конец
					-- если инд>1 и пер[инд-1]:подстр(-2,-1)=="?"
					-- 	локал у = узел[элем] 
					-- 	если не у 
					-- 		у = {}
					-- 		узел[элем] = у
					-- 	конец
					-- 		
					-- конец

					узел = у
				конец

				возврат я
			конец,
			путькузлу = функция(я, путь)
				локал узел = я
				для кл из путь:gmatch"(%S+)"
					узел = узел[кл]
				конец
				возврат узел
			конец,
		}
	}


	локал новый = устметатаб({}, мт)
	если п тогда новый:добпер(п) конец
	возврат новый
конец

функция П(...)
	локал мт = {
		__tostring = функция(я)
			возврат table.concat(я, " ")
		конец,
		__add = функция(а, б)
			возврат Д(а):добпер(б)
		конец,
		__индекс = { имя=имя,
			вдрево = функция(я, новый)
				локал новый = новый или {}
				локал узел = новый
				для инд, элем из перечисли(я)
					локал у = узел[элем] 
					если не у 
						у = {}
						узел[элем] = у
					конец
					узел = у
				конец

				возврат устметатаб(новый, мт)
			конец,
		}
	}


	локал новый = {...}

	возврат устметатаб(новый, мт)

конец

функция Пстр(стр)
	локал новый = {}
	для арг из стр:gmatch"(%S+)"
		table.insert(новый, арг)
	конец
	возврат П(table.unpack(новый))
конец

ес = П("если", "значение", "тогда", "блок", "конец")
есин = П("если", "значение", "тогда", "блок", "иначе", "блок", "конец")
печать(ес)
печать(есин)
е = ес+есин
печать(е)
пк = Пстр"пока значение начало блок конец"
пк2 = Пстр"пока значение блок конец"
ес2 = Пстр"если значение блок конец"
-- есин2 = Пстр"если значение блок иначе блок конец"
е:добпер(пк)
е:добпер(пк2)
печать(е)
-- е:добпер(ес2)
-- е:добпер(есин2)
е["если"]["значение"]["блок"] = е["если"]["значение"]["тогда"]["блок"]
печать(е)
е:путькузлу"если значение тогда блок"["иначе"]={ ["блок"]={ ["конец"]={} } }
ие = {}
ие["значение"]={ ["блок"]=ие  } 
е:путькузлу"если значение тогда блок"["иесли"]=ие
печать(е)